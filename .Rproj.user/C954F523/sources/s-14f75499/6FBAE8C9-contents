#Goal: write a play() function that return a slot machine output
  #Needs to randomly generate three symbols
  #Needs to calculate a prize based on those symbols

get_symbols <- function() {
  wheel<-c("DD", "7", "BBB", "BB", "B", "C", "0")
  sample(wheel, size=3, replace=TRUE, prob=c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52))
}

get_symbols()
get_symbols()
get_symbols()
#The get_symbols() function assigns all the symbols to wheel. Then it samples 3 objects from wheel with replacement.
  #Next, it uses prob to assign probability weights to each of the sample elements being retrieved. For example,
  #B has a prob of 0.25 and is called a quarter of the time.

#But what are the win conditions of get_symbol()?
  #1. Three of the same type of symbol (except zeros)
  #2. Three bars of mixed variety
  #3. one or more cherries

#Sequential Steps
play<-function(){
  symbols<-get_symbols()
  print(symbols)
  score(symbols)
}
#First play generates symbols, then it displays the symbols, then it scores the symbols

play()
#Still haven't written score so calling play doesn't work yet!

num<- -2
if(num<0){
  num<-num*-1
}
num

num<-4
if(num<0){
  num<-num*-1
}
num

num <- -1
if (num < 0) {
  print("num is negative.")
  print("Don't worry, I'll fix it.")
  num <- num * -1
  print("Now num is positive.")
}
num
#You can throw some wild shit inside an if statement.

x <- 1
if (3 == 3) {
  x <- 2
}
x

x <- 1
if (x == 1) {
  x <- 2
  if (x == 1) {
    x <- 3
  }
}
x
#if statements can evaluate if something is true and execute code accordingly. What is true can be internal to the statement.

a<-3.14
dec<-a-trunc(a)
dec
#trunc() only returns the integer part (left of decimal). a-trunc(a) is a good way to return the decimal

if (dec>=0.5){
  a<-trunc(a)+1
} else {
  a<-trunc(a)
}
a
#Above code asks if dec (which is = to 0.14) is greater than 0.5 and decides it isn't. Then the else statement is executed.
  #Else assigns trunc(a) (which is = to 3) to a. a returns 3.

a<-1
b<-1
if(a>b){
  print("A wins!")
} else if (a<b){
  print("B wins!")
} else{
  print("Tie.")
}

#Nest if and else statements by using an else if statement!

#if (same) {
  #prize <- # look up the prize
#} else if ( # Case 2: all bars ) {
  #prize <- # assign $5
  #} else {
    #count cherries
    #prize <- calculate a prize
#}
# count diamonds
# double the prize if necessary

#Per the workbook, we have many sub-tasks to complete and it would be wise to write an example for each that we can
  #test our code on.

symbols<-c("7","7","7")
#Symbols should be changed to evaluate each sub-task

symbols
symbols[1]==symbols[2] & symbols[2]==symbols[3]
all(symbols==symbols[1])
#Both statements evaluate symbols in a different order but equally conclude that all symbols are the same.

length(unique(symbols)==1)
#This code does the same as the above. It firsts checks if the symbols vector contains unique values and returns them. Then
  #it will return a vector length of 1.

symbols<-c("7","8","D")
length(unique(symbols)==1)
#An example of the above.
symbols<-c("7","7","7")

same<-symbols[1]==symbols[2] & symbols[2]==symbols[3]
#if (same) {
#prize <- # look up the prize
#} else if ( # Case 2: all bars ) {
#prize <- # assign $5
#} else {
#count cherries
#prize <- calculate a prize
#}
# count diamonds
# double the prize if necessary

((-2:2) >= 0) & ((-2:2) <= 0)
#[1] FALSE FALSE  TRUE FALSE FALSE
((-2:2) >= 0) && ((-2:2) <= 0)
#[1] FALSE
#& will interpret and return all conclusions from the code. && will "short circuit" and if the first value is false
  #it will only return FALSE because a true and a false only make a false. Same as | and ||

symbols <- c("B", "BBB", "BB")

symbols[1] == "B" | symbols[1] == "BB" | symbols[1] == "BBB" &
  symbols[2] == "B" | symbols[2] == "BB" | symbols[2] == "BBB" &
  symbols[3] == "B" | symbols[3] == "BB" | symbols[3] == "BBB"
#Damn that's a lot of code and comparisons R has to run. Could we compress this at all?

all(symbols %in% c("B", "BB", "BBB"))
#The longer code asks if one or more of condition one/condition two/condition 3 are true. It has to check all three
  #combinations that B/BB/BBB could be in. The shorter line of code asks if symbols is in group c("B", "BB", "BBB").
  #We can use all to ask if all the symbols are in group c.

same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
bars <- symbols %in% c("B", "BB", "BBB")

if (same) {
  prize <- # look up the prize
} else if (all(bars)) {
  prize <- # assign $5
} else {
  # count cherries
  prize <- # calculate a prize
}
# count diamonds
# double the prize if necessary

#Order of all(bars) changed to be more readable.

symbols <- c("B", "B", "B")
all(symbols %in% c("B", "BB", "BBB"))
#Case two function will capture some symbols that should be in case 1 because they are three of a kind. This is fine bc
  #we've used an else if and when R evaluates a case TRUE it will skip over the rest.

if (same) {
  symbol <- symbols[1]
  if (symbol == "DD") {
    prize <- 800
  } else if (symbol == "7") {
    prize <- 80
  } else if (symbol == "BBB") {
    prize <- 40
  } else if (symbol == "BB") {
    prize <- 5
  } else if (symbol == "B") {
    prize <- 10
  } else if (symbol == "C") {
    prize <- 10
  } else if (symbol == "0") {
    prize <- 0
  }
}
#This code allows us to look up the prize based on the symbol in a set of three. It's kind of long though...

payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25, "B" = 10, "C" = 10, "0" = 0)
payouts
#Instead of using a ton of if statements you could use a lookup table that consists of a vector that stores symbols and prize values.

payouts["DD"]
payouts["B"]
#By subsetting the vector with the symbol's name you can extract the correct prize!

unname(payouts["DD"])
#The unname function leaves out the symbol's name

symbols<-c("7","7","7")
symbols[1]

payouts[symbols[1]]

symbols <- c("C", "C", "C")
payouts[symbols[1]]
#Don't need to provide R the symbols to lookup bc R will use the data that is in symbols. Can be used for symbols[1], symbols[2], or symbols[3]

same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
bars <- symbols %in% c("B", "BB", "BBB")

if (same) {
  payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25, 
               "B" = 10, "C" = 10, "0" = 0)
  prize <- unname(payouts[symbols[1]])
} else if (all(bars)) {
  prize <- 5
} else {
  # count cherries
  prize <- # calculate a prize
}

# count diamonds
# double the prize if necessary

symbols<-c("C","DD","C")
symbols=="C"
sum(symbols=="C")
sum(symbols=="DD")
#R will coerce TRUE and FALSE into 1 and 0 which works with the sum function. 

same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
bars <- symbols %in% c("B", "BB", "BBB")

if (same) {
  payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25, 
               "B" = 10, "C" = 10, "0" = 0)
  prize <- unname(payouts[symbols[1]])
} else if (all(bars)) {
  prize <- 5
} else {
  cherries <- sum(symbols == "C")
  prize <- # calculate a prize
}

diamonds <- sum(symbols == "DD")
# double the prize if necessary

if (cherries == 2) {
  prize <- 5
} else if (cherries == 1) {
  prize <- 2
} else {}
prize <- 0
}
#To figure out the payout based on the number of cherries we could use the above if/else statements. Or we can use subsetting again.

c(0,2,5)
#We will store the cherry values in a simple lookup table.

cherries+1
c(0,2,5)[cherries+1]
#We have to add 1 to cherries so it can return 0 if there are no cherries.

same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
#Checks if the first symbol is equal to the second and the second equal to the third. Assigns this value to same.
bars <- symbols %in% c("B", "BB", "BBB")
#Checks if the symbols are some combination of B, BB, and BBB. Assigns value to bars based on the number that matches.
#Both checks are ways to identify case.

if (same) {
  payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25, 
               "B" = 10, "C" = 10, "0" = 0)
  prize <- unname(payouts[symbols[1]])
  #First a list of symbols and their values are assigned to payouts. Then the symbol value (via payouts list) is assigned to prize but the symbol name isn't brought with it.
} else if (all(bars)) {
  prize <- 5
  #
} else {
  cherries <- sum(symbols == "C")
  prize <- c(0, 2, 5)[cherries + 1]
  #Assigns a prize based on the number of cherries.
}

diamonds <- sum(symbols == "DD")
prize * 2 ^ diamonds
#First, the sum of the number of diamonds (DD) is added to diamonds. Then, it multiplies the score by 2 to the power of the number of diamonds.

#Creating a function out of the above code.
score <- function (symbols) {
  same <- symbols[1] == symbols[2] && symbols[2] == symbols[3]
  bars <- symbols %in% c("B", "BB", "BBB")
  if (same) {
    payouts <- c("DD" = 100, "7" = 80, "BBB" = 40, "BB" = 25, 
                 "B" = 10, "C" = 10, "0" = 0)
    prize <- unname(payouts[symbols[1]])
  } else if (all(bars)) {
    prize <- 5
  } else {
    cherries <- sum(symbols == "C")
    prize <- c(0, 2, 5)[cherries + 1]
  }
  diamonds <- sum(symbols == "DD")
  prize * 2 ^ diamonds
}

#Creating the play function.
play <- function() {
  symbols <- get_symbols()
  print(symbols)
  score(symbols)
}

play()
play()
play()